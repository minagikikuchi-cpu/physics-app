<code id="physics_motion_analyzer_app_v2" title="物理 運動分析アプリ（安定版）" language="html" file_path="physics_motion_analyzer_app_stable.html">
<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>物理 運動分析アプリ</title>
<!-- Tailwind CSSを読み込み、モダンなデザインを適用します -->
<script src="https://cdn.tailwindcss.com"></script>
<!-- Chart.jsを読み込み、グラフ描画に使用します -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
/* Google Fontsから丸みのあるフォントを読み込みます /
@import url('https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;500;700&display=swap');
body {
font-family: 'M PLUS Rounded 1c', sans-serif;
/ 背景に薄いグラデーションを追加 /
background-color: #fce7f3; / pink-50 /
background-image: linear-gradient(135deg, #fce7f3 0%, #f3e8ff 100%); / pink-50 to purple-50 /
}
/ キラキラアニメーションの定義 /
@keyframes sparkle {
0%, 100% { box-shadow: 0 0 10px #f9a8d4, 0 0 20px #f9a8d4, 0 0 30px #f9a8d4; }
50% { box-shadow: 0 0 20px #f472b6, 0 0 30px #f472b6, 0 0 40px #f472b6; }
}
/ アクティブなステップのスタイル /
.step-active {
background-image: linear-gradient(to right, #ec4899, #d946ef); / pink-500 to fuchsia-500 /
color: white;
transform: scale(1.1);
animation: sparkle 2.5s infinite ease-in-out;
}
/ ボタンが無効な時のスタイル /
button:disabled {
background-image: none;
background-color: #d1d5db; / gray-300 /
cursor: not-allowed;
box-shadow: none;
}
/ カード全体のスタイル /
.card {
background-color: rgba(255, 255, 255, 0.8);
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
border-radius: 24px;
padding: 24px;
box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.05), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
border: 1px solid rgba(255, 255, 255, 0.2);
}
/ ボタンの共通スタイル /
.btn {
font-weight: bold;
padding-top: 0.75rem;
padding-bottom: 0.75rem;
padding-left: 1.5rem;
padding-right: 1.5rem;
border-radius: 9999px;
transition: all 0.3s ease;
box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
border: none;
color: white;
}
.btn:hover:not(:disabled) {
transform: translateY(-3px) scale(1.05);
box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05);
}
/ ファイル選択ボタンのスタイル /
input[type="file"]::file-selector-button {
border-radius: 9999px;
padding: 0.5rem 1rem;
border: none;
font-weight: 600;
cursor: pointer;
transition: all 0.2s ease-in-out;
background-color: #fbcfe8; / pink-200 /
color: #be185d; / pink-700 /
}
input[type="file"]::file-selector-button:hover {
background-color: #f9a8d4; / pink-300 /
}
/ グラフ選択ボタンのアクティブスタイル */
.graph-btn-active {
background-image: linear-gradient(to right, #ec4899, #d946ef);
color: white;
}
</style>
</head>
<body class="text-gray-700">

<div class="container mx-auto p-4 md:p-8 max-w-5xl">
    <!-- ヘッダー部分 -->
    <header class="text-center mb-8">
        <h1 class="text-4xl font-bold text-pink-500">物理 運動分析アプリ</h1>
        <p class="mt-2 text-lg text-gray-500">動画で楽しく物理を探求しよう！</p>
    </header>

    <!-- メインコンテンツ -->
    <main id="mainContent">
        
        <!-- ステップ表示 -->
        <div class="flex justify-center items-center space-x-2 sm:space-x-4 mb-8">
            <div id="step-1-indicator" class="step-active flex items-center justify-center w-12 h-12 rounded-full font-bold text-lg transition-all duration-300">1</div>
            <div class="flex-1 h-1 bg-gray-200"></div>
            <div id="step-2-indicator" class="flex items-center justify-center w-12 h-12 rounded-full bg-white font-bold text-lg transition-all duration-300">2</div>
            <div class="flex-1 h-1 bg-gray-200"></div>
            <div id="step-3-indicator" class="flex items-center justify-center w-12 h-12 rounded-full bg-white font-bold text-lg transition-all duration-300">3</div>
            <div class="flex-1 h-1 bg-gray-200"></div>
            <div id="step-4-indicator" class="flex items-center justify-center w-12 h-12 rounded-full bg-white font-bold text-lg transition-all duration-300">4</div>
        </div>

        <!-- ステップ1: 動画のアップロード -->
        <div id="step-1" class="card">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">ステップ1: 動画を選択</h2>
            <p class="mb-4 text-gray-600">分析したい物体の運動が撮影された動画ファイル（.mp4, .movなど）を選んでください。</p>
            <input type="file" id="videoUpload" accept="video/*" class="block w-full text-sm text-gray-500">
        </div>

        <!-- ステップ2: 基準距離の設定 -->
        <div id="step-2" class="card mt-8 hidden">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">ステップ2: 基準を設定</h2>
            <p class="mb-4 text-gray-600">動画内に定規など長さが分かる物があれば、その両端をクリックして実際の長さを入力してください。</p>
            <div class="grid md:grid-cols-2 gap-6 items-start">
                <div>
                    <canvas id="calibrationCanvas" class="w-full rounded-2xl border-2 border-gray-200 cursor-crosshair"></canvas>
                </div>
                <div class="flex flex-col space-y-4">
                    <div>
                        <label for="realDistance" class="block text-sm font-medium text-gray-700">実際の長さ (メートル)</label>
                        <input type="number" id="realDistance" value="1.0" step="0.01" class="mt-1 block w-full rounded-xl border-gray-300 shadow-sm focus:border-pink-500 focus:ring-pink-500 sm:text-sm">
                    </div>
                    <div class="text-sm bg-gray-50 p-3 rounded-xl">
                        <p>ピクセルでの長さ: <span id="pixelDistance" class="font-mono">0</span> px</p>
                        <p>スケール: <span id="scale" class="font-mono">?</span> m/px</p>
                    </div>
                    <button id="skipCalibration" class="btn bg-gray-400 hover:bg-gray-500">このまま進む (ピクセル単位)</button>
                    <button id="confirmCalibration" class="btn" style="background-image: linear-gradient(to right, #ec4899, #d946ef);">設定を決定！</button>
                    <button id="backToStep1" class="btn bg-gray-200 text-gray-700 hover:bg-gray-300">動画を選びなおす</button>
                </div>
            </div>
        </div>

        <!-- ステップ3: 手動トラッキング -->
        <div id="step-3" class="card mt-8 hidden">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">ステップ3: 物体を追跡</h2>
            <p class="mb-4 text-gray-600">動画の1コマずつ、追跡したい物体をクリックしてください。クリックすると次のコマに進みます。</p>
            <div class="grid md:grid-cols-3 gap-6 items-start">
                <div class="md:col-span-2">
                    <canvas id="trackingCanvas" class="w-full rounded-2xl border-2 border-gray-200 cursor-crosshair"></canvas>
                </div>
                <div>
                    <div class="mb-4">
                        <label for="frameRateSelect" class="block text-sm font-medium text-gray-700">分析の細かさ (フレームレート)</label>
                        <select id="frameRateSelect" class="mt-1 block w-full rounded-xl border-gray-300 shadow-sm focus:border-pink-500 focus:ring-pink-500 sm:text-sm">
                            <option value="30">標準 (30 fps)</option>
                            <option value="60">高精度 (60 fps)</option>
                            <option value="15">簡易 (15 fps)</option>
                        </select>
                    </div>
                    <div class="mb-4 p-4 bg-gray-50 rounded-xl">
                        <p class="text-sm font-medium text-gray-700">進捗</p>
                        <div class="w-full bg-gray-200 rounded-full h-2.5 mt-2">
                            <div id="progressBar" class="h-2.5 rounded-full transition-all duration-300" style="width: 0%; background-image: linear-gradient(to right, #fbcfe8, #f472b6);"></div>
                        </div>
                        <p id="frameIndicator" class="text-center text-sm mt-2 font-mono">フレーム: 0 / 0</p>
                    </div>
                    <div class="grid grid-cols-3 gap-2 mb-4">
                        <button id="prevFrameBtn" class="btn bg-gray-400 text-sm p-2 hover:bg-gray-500">前へ</button>
                        <button id="clearMarkerBtn" class="btn bg-pink-500 text-sm p-2 hover:bg-pink-600">消去</button>
                        <button id="nextFrameBtn" class="btn bg-gray-400 text-sm p-2 hover:bg-gray-500">次へ</button>
                    </div>
                    <button id="finishTracking" class="btn w-full" style="background-image: linear-gradient(to right, #f9a8d4, #ec4899);">分析する！</button>
                    <button id="backToStep2" class="btn w-full mt-4 bg-gray-200 text-gray-700 hover:bg-gray-300">基準設定に戻る</button>
                </div>
            </div>
        </div>
        
        <div id="step-4" class="card mt-8 hidden">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">ステップ4: 分析結果</h2>
            <div id="resultsContainer">
                <!-- サマリー表示エリア -->
                <h3 class="text-xl font-bold mb-2">サマリー</h3>
                <div id="summarySection" class="grid grid-cols-2 sm:grid-cols-4 gap-4 mb-6 text-center">
                    <!-- サマリーデータがここに挿入されます -->
                </div>

                <!-- グラフ表示エリア -->
                <h3 class="text-xl font-bold mb-2">グラフ</h3>
                <div class="flex justify-center flex-wrap gap-2 mb-4 border-b pb-4">
                    <button id="showPositionChart" class="btn btn-sm graph-btn-active bg-gray-200 text-gray-700">位置</button>
                    <button id="showVelocityChart" class="btn btn-sm bg-gray-200 text-gray-700">速度</button>
                    <button id="showAccelerationChart" class="btn btn-sm bg-gray-200 text-gray-700">加速度</button>
                    <button id="showTrajectoryChart" class="btn btn-sm bg-gray-200 text-gray-700">軌跡</button>
                </div>
                <div class="relative h-80 sm:h-96">
                    <canvas id="mainChart"></canvas>
                </div>

                <!-- 詳細データテーブル -->
                <h3 class="text-xl font-bold mt-8 mb-2">詳細データ</h3>
                <div class="h-64 overflow-auto border rounded-xl">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">時間(s)</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">x</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">y</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">vx</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">vy</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ax</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ay</th>
                            </tr>
                        </thead>
                        <tbody id="dataTableBody" class="bg-white divide-y divide-gray-200">
                        </tbody>
                    </table>
                </div>
                
                 <!-- 操作ボタンエリア -->
                 <div class="flex flex-col sm:flex-row gap-4 mt-8">
                    <button id="downloadCsvBtn" class="btn w-full bg-green-400 hover:bg-green-500">CSVダウンロード</button>
                    <button id="downloadGraphBtn" class="btn w-full bg-purple-400 hover:bg-purple-500">グラフを保存</button>
                    <button id="backToStep3" class="btn w-full bg-gray-200 text-gray-700 hover:bg-gray-300">追跡画面に戻る</button>
                    <button onclick="location.reload()" class="btn w-full" style="background-image: linear-gradient(to right, #a5b4fc, #818cf8);">はじめから</button>
                 </div>
            </div>
        </div>
    </main>
</div>

<script>
    // グローバル変数の定義
    let videoElement = document.createElement('video');
    let firstFrame;
    let calibrationPoints = [];
    let scale = 1.0;
    let unit = 'px';
    
    let totalFrames = 0;
    let currentFrameIndex = 0;
    let frameRate = 30;
    let trackedPositions = [];
    
    let chartDataStore = {};
    let fullData = [];
    let activeChart;
    let activeChartType = 'position';

    // ステップ表示を更新する関数
    function updateStepIndicator(currentStep) {
        for (let i = 1; i <= 4; i++) {
            const indicator = document.getElementById(`step-${i}-indicator`);
            const stepDiv = document.getElementById(`step-${i}`);
            indicator.classList.remove('step-active', 'bg-white');
            if (i < currentStep) {
                indicator.classList.add('bg-green-400', 'text-white');
                indicator.style.animation = 'none';
            } else if (i === currentStep) {
                indicator.classList.add('step-active');
                if(stepDiv) stepDiv.classList.remove('hidden');
            } else {
                indicator.classList.add('bg-white');
                indicator.style.animation = 'none';
            }
        }
    }

    // 動画読み込みの処理
    document.getElementById('videoUpload').addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;

        firstFrame = null;
        calibrationPoints = [];
        videoElement = document.createElement('video'); 
        
        videoElement.addEventListener('loadeddata', () => {
            if (firstFrame) return;

            const canvas = document.getElementById('calibrationCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = videoElement.videoWidth;
            canvas.height = videoElement.videoHeight;
            
            ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
            
            const tempCtx = document.createElement('canvas').getContext('2d');
            tempCtx.canvas.width = canvas.width;
            tempCtx.canvas.height = canvas.height;
            tempCtx.drawImage(videoElement, 0, 0);
            firstFrame = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
            
            document.getElementById('step-1').classList.add('hidden');
            document.getElementById('step-2').classList.remove('hidden');
            updateStepIndicator(2);
        }, { once: true });

        videoElement.src = URL.createObjectURL(file);
        videoElement.currentTime = 0;
    });

    // --- ステップ2: キャリブレーション ---
    const calibrationCanvas = document.getElementById('calibrationCanvas');
    const caliCtx = calibrationCanvas.getContext('2d');

    calibrationCanvas.addEventListener('click', (event) => {
        const rect = calibrationCanvas.getBoundingClientRect();
        const scaleX = calibrationCanvas.width / rect.width;
        const scaleY = calibrationCanvas.height / rect.height;
        const x = (event.clientX - rect.left) * scaleX;
        const y = (event.clientY - rect.top) * scaleY;

        if (calibrationPoints.length >= 2) {
            calibrationPoints = [];
        }
        calibrationPoints.push({ x, y });

        caliCtx.putImageData(firstFrame, 0, 0);
        calibrationPoints.forEach(p => {
            caliCtx.beginPath();
            caliCtx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
            caliCtx.fillStyle = 'rgba(236, 72, 153, 0.8)';
            caliCtx.fill();
        });

        if (calibrationPoints.length === 2) {
            const p1 = calibrationPoints[0];
            const p2 = calibrationPoints[1];
            caliCtx.beginPath();
            caliCtx.moveTo(p1.x, p1.y);
            caliCtx.lineTo(p2.x, p2.y);
            caliCtx.strokeStyle = '#ec4899';
            caliCtx.lineWidth = 3;
            caliCtx.stroke();
            
            const dist = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
            document.getElementById('pixelDistance').textContent = dist.toFixed(2);
        }
    });

    document.getElementById('confirmCalibration').addEventListener('click', () => {
        if (calibrationPoints.length === 2) {
            const realDist = parseFloat(document.getElementById('realDistance').value);
            const pixelDist = parseFloat(document.getElementById('pixelDistance').textContent);
            if (realDist > 0 && pixelDist > 0) {
                scale = realDist / pixelDist;
                unit = 'm';
                document.getElementById('scale').textContent = `${scale.toExponential(4)} m/px`;
            }
        }
        goToStep3();
    });
    
    document.getElementById('skipCalibration').addEventListener('click', () => {
        scale = 1.0;
        unit = 'px';
        document.getElementById('scale').textContent = `1.0 px/px`;
        goToStep3();
    });

    document.getElementById('backToStep1').addEventListener('click', () => {
        document.getElementById('step-2').classList.add('hidden');
        document.getElementById('step-1').classList.remove('hidden');
        updateStepIndicator(1);
        videoElement.src = '';
        firstFrame = null;
        calibrationPoints = [];
        document.getElementById('pixelDistance').textContent = '0';
        document.getElementById('scale').textContent = '?';
        const canvas = document.getElementById('calibrationCanvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        document.getElementById('videoUpload').value = null;
    });

    function goToStep3() {
        document.getElementById('step-2').classList.add('hidden');
        document.getElementById('step-3').classList.remove('hidden');
        updateStepIndicator(3);
        frameRate = parseInt(document.getElementById('frameRateSelect').value);
        totalFrames = Math.floor(videoElement.duration * frameRate);
        trackedPositions = new Array(totalFrames).fill(null);
        currentFrameIndex = 0;
        drawTrackingFrame();
    }

    // --- ステップ3: 手動追跡 ---
    const trackingCanvas = document.getElementById('trackingCanvas');
    const trackingCtx = trackingCanvas.getContext('2d');

    async function drawTrackingFrame() {
        const time = currentFrameIndex / frameRate;
        videoElement.currentTime = time;
        
        await new Promise(resolve => {
            videoElement.onseeked = () => resolve();
        });

        trackingCanvas.width = videoElement.videoWidth;
        trackingCanvas.height = videoElement.videoHeight;
        trackingCtx.drawImage(videoElement, 0, 0);

        if (trackedPositions[currentFrameIndex]) {
            const pos = trackedPositions[currentFrameIndex];
            const markerRadius = 18;
            trackingCtx.beginPath();
            trackingCtx.arc(pos.rawX, pos.rawY, markerRadius + 4, 0, 2 * Math.PI);
            trackingCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            trackingCtx.fill();

            trackingCtx.beginPath();
            trackingCtx.arc(pos.rawX, pos.rawY, markerRadius, 0, 2 * Math.PI);
            trackingCtx.fillStyle = 'rgba(236, 72, 153, 0.85)'; // pink-500
            trackingCtx.fill();

            trackingCtx.beginPath();
            trackingCtx.arc(pos.rawX, pos.rawY, 4, 0, 2 * Math.PI);
            trackingCtx.fillStyle = 'white';
            trackingCtx.fill();
        }
        updateTrackingUI();
    }
    
    function updateTrackingUI() {
        document.getElementById('frameIndicator').textContent = `フレーム: ${currentFrameIndex + 1} / ${totalFrames}`;
        const progress = totalFrames > 0 ? ((currentFrameIndex + 1) / totalFrames) * 100 : 0;
        document.getElementById('progressBar').style.width = `${progress}%`;
        document.getElementById('prevFrameBtn').disabled = currentFrameIndex === 0;
        document.getElementById('nextFrameBtn').disabled = currentFrameIndex === totalFrames - 1;
        document.getElementById('clearMarkerBtn').disabled = trackedPositions[currentFrameIndex] === null;
    }

    trackingCanvas.addEventListener('click', (event) => {
        const rect = trackingCanvas.getBoundingClientRect();
        const scaleX = trackingCanvas.width / rect.width;
        const scaleY = trackingCanvas.height / rect.height;
        const x = (event.clientX - rect.left) * scaleX;
        const y = (event.clientY - rect.top) * scaleY;
        
        trackedPositions[currentFrameIndex] = {
            frame: currentFrameIndex,
            t: currentFrameIndex / frameRate,
            x: x * scale,
            y: (trackingCanvas.height - y) * scale,
            rawX: x,
            rawY: y
        };
        
        if (currentFrameIndex < totalFrames - 1) {
            currentFrameIndex++;
        }
        drawTrackingFrame();
    });

    document.getElementById('prevFrameBtn').addEventListener('click', () => {
        if (currentFrameIndex > 0) {
            currentFrameIndex--;
            drawTrackingFrame();
        }
    });

    document.getElementById('nextFrameBtn').addEventListener('click', () => {
        if (currentFrameIndex < totalFrames - 1) {
            currentFrameIndex++;
            drawTrackingFrame();
        }
    });
    
    document.getElementById('clearMarkerBtn').addEventListener('click', () => {
        if (trackedPositions[currentFrameIndex] !== null) {
            trackedPositions[currentFrameIndex] = null;
            drawTrackingFrame();
        }
    });

    document.getElementById('backToStep2').addEventListener('click', () => {
        document.getElementById('step-3').classList.add('hidden');
        document.getElementById('step-2').classList.remove('hidden');
        updateStepIndicator(2);
        trackedPositions = [];
    });

    document.getElementById('finishTracking').addEventListener('click', () => {
        const finalPositions = trackedPositions.filter(p => p !== null);
        if (finalPositions.length < 2) {
            alert('少なくとも2点以上を追跡してください。');
            return;
        }
        document.getElementById('step-3').classList.add('hidden');
        document.getElementById('step-4').classList.remove('hidden');
        updateStepIndicator(4);
        calculateAndDisplayResults(finalPositions);
    });

    // --- ステップ4: 分析結果表示 ---
    document.getElementById('backToStep3').addEventListener('click', () => {
        document.getElementById('step-4').classList.add('hidden');
        document.getElementById('step-3').classList.remove('hidden');
        updateStepIndicator(3);
        if(activeChart) {
            activeChart.destroy();
            activeChart = null;
        }
    });

    function calculateAndDisplayResults(positions) {
        fullData = [];
        for (let i = 0; i < positions.length; i++) {
            const p = positions[i];
            let vx = 0, vy = 0, ax = 0, ay = 0;

            if (i > 0) {
                const p_prev = positions[i - 1];
                const dt = p.t - p_prev.t;
                if (dt > 0) {
                    vx = (p.x - p_prev.x) / dt;
                    vy = (p.y - p_prev.y) / dt;
                }
            }
            
            const currentData = { t: p.t, x: p.x, y: p.y, vx, vy, ax, ay };

            if (i > 1) {
                const prevData = fullData[i - 1];
                const dt = currentData.t - prevData.t;
                if (dt > 0) {
                    ax = (currentData.vx - prevData.vx) / dt;
                    ay = (currentData.vy - prevData.vy) / dt;
                }
            }
            currentData.ax = ax;
            currentData.ay = ay;
            fullData.push(currentData);
        }

        const tableBody = document.getElementById('dataTableBody');
        tableBody.innerHTML = '';
        fullData.forEach(d => {
            const row = `<tr>
                <td class="px-6 py-4 whitespace-nowrap text-sm">${d.t.toFixed(3)}</td>
                <td class="px-6 py-4 whitespace-nowrap text-sm">${d.x.toFixed(3)}</td>
                <td class="px-6 py-4 whitespace-nowrap text-sm">${d.y.toFixed(3)}</td>
                <td class="px-6 py-4 whitespace-nowrap text-sm">${d.vx.toFixed(3)}</td>
                <td class="px-6 py-4 whitespace-nowrap text-sm">${d.vy.toFixed(3)}</td>
                <td class="px-6 py-4 whitespace-nowrap text-sm">${d.ax.toFixed(3)}</td>
                <td class="px-6 py-4 whitespace-nowrap text-sm">${d.ay.toFixed(3)}</td>
            </tr>`;
            tableBody.innerHTML += row;
        });
        
        const labels = fullData.map(d => d.t.toFixed(3));
        const x_pos = fullData.map(d => d.x);
        const y_pos = fullData.map(d => d.y);
        const vx = fullData.map(d => d.vx);
        const vy = fullData.map(d => d.vy);
        const ax = fullData.map(d => d.ax);
        const ay = fullData.map(d => d.ay);
        const colors = { x: '#f43f5e', y: '#8b5cf6', trajectory: '#10b981' };

        chartDataStore = {
            position: { config: createChartConfig(`x, y [${unit}]`, labels, [{label: `x [${unit}]`, data: x_pos, borderColor: colors.x}, {label: `y [${unit}]`, data: y_pos, borderColor: colors.y}]) },
            velocity: { config: createChartConfig(`vx, vy [${unit}/s]`, labels, [{label: `vx [${unit}/s]`, data: vx, borderColor: colors.x}, {label: `vy [${unit}/s]`, data: vy, borderColor: colors.y}]) },
            acceleration: { config: createChartConfig(`ax, ay [${unit}/s²]`, labels, [{label: `ax [${unit}/s²]`, data: ax, borderColor: colors.x}, {label: `ay [${unit}/s²]`, data: ay, borderColor: colors.y}]) },
            trajectory: { config: createChartConfig(`y [${unit}]`, x_pos, [{label: `軌跡`, data: y_pos, borderColor: colors.trajectory}], 'x', `x [${unit}]`) }
        };

        displaySummary(fullData);
        renderChart('position');
    }

    function displaySummary(data) {
        const summarySection = document.getElementById('summarySection');
        summarySection.innerHTML = '';

        if (data.length === 0) return;

        const y_pos = data.map(d => d.y);
        const x_pos = data.map(d => d.x);
        const speeds = data.map(d => Math.sqrt(d.vx**2 + d.vy**2));

        const maxHeight = Math.max(...y_pos);
        const horizontalRange = Math.max(...x_pos) - Math.min(...x_pos);
        const maxSpeed = Math.max(...speeds);
        const totalTime = data[data.length - 1].t - data[0].t;

        const summaries = [
            { label: '最高到達点', value: maxHeight.toFixed(3), unit: unit },
            { label: '水平到達距離', value: horizontalRange.toFixed(3), unit: unit },
            { label: '最大速度', value: maxSpeed.toFixed(3), unit: `${unit}/s` },
            { label: '合計時間', value: totalTime.toFixed(3), unit: 's' }
        ];

        summaries.forEach(s => {
            const el = document.createElement('div');
            el.className = 'bg-white/50 p-3 rounded-xl';
            el.innerHTML = `<p class="text-sm text-gray-500">${s.label}</p><p class="text-xl font-bold text-pink-500">${s.value} <span class="text-sm font-normal">${s.unit}</span></p>`;
            summarySection.appendChild(el);
        });
    }

    function renderChart(type) {
        if (activeChart) {
            activeChart.destroy();
        }
        const ctx = document.getElementById('mainChart').getContext('2d');
        activeChart = new Chart(ctx, chartDataStore[type].config);
        activeChartType = type;

        document.querySelectorAll('#step-4 .graph-btn-active').forEach(btn => {
            btn.classList.remove('graph-btn-active');
        });
        document.getElementById(`show${type.charAt(0).toUpperCase() + type.slice(1)}Chart`).classList.add('graph-btn-active');
    }
    
    document.getElementById('showPositionChart').addEventListener('click', () => renderChart('position'));
    document.getElementById('showVelocityChart').addEventListener('click', () => renderChart('velocity'));
    document.getElementById('showAccelerationChart').addEventListener('click', () => renderChart('acceleration'));
    document.getElementById('showTrajectoryChart').addEventListener('click', () => renderChart('trajectory'));

    document.getElementById('downloadCsvBtn').addEventListener('click', () => {
        if (fullData.length === 0) return;
        const headers = "時間(s),x,y,vx,vy,ax,ay";
        const csvContent = "data:text/csv;charset=utf-8," 
            + headers + "\n"
            + fullData.map(d => `${d.t.toFixed(3)},${d.x.toFixed(3)},${d.y.toFixed(3)},${d.vx.toFixed(3)},${d.vy.toFixed(3)},${d.ax.toFixed(3)},${d.ay.toFixed(3)}`).join("\n");
        
        const encodedUri = encodeURI(csvContent);
        const link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", "analysis_data.csv");
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    });

    document.getElementById('downloadGraphBtn').addEventListener('click', () => {
        if (!activeChart) return;
        const link = document.createElement('a');
        link.href = activeChart.toBase64Image();
        link.download = `${activeChartType}_graph.png`;
        link.click();
    });
    
    function createChartConfig(title, labels, datasets, xAxisType = 't', xAxisTitle = 'Time [s]') {
        return {
            type: 'line',
            data: {
                labels: labels,
                datasets: datasets.map(ds => ({
                    ...ds,
                    fill: false,
                    borderWidth: 2.5,
                    pointRadius: 1,
                    tension: 0.1
                }))
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: { display: false },
                    legend: { position: 'top', labels: {font: { family: "'M PLUS Rounded 1c', sans-serif" }} },
                },
                scales: {
                    x: { title: { display: true, text: xAxisTitle, font: { family: "'M PLUS Rounded 1c', sans-serif" }} },
                    y: { title: { display: true, text: title, font: { family: "'M PLUS Rounded 1c', sans-serif" }} }
                }
            }
        };
    }
    
    updateStepIndicator(1);
</script>
</body>
</html>
